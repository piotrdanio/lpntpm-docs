{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About lpnTPM is Open Source Software (OSS), and Open Source Hardware (OSHW) Trusted Platform Module (TPM, also known as ISO/IEC 11889) is an international standard for a secure cryptoprocessor, a dedicated microcontroller designed to secure hardware through integrated cryptographic keys. What makes lpnTPM different from generally available solutions is openness. Software and hardware of lpnTPM can, without limits, be audited, fixed, and customized by communities and businesses. Open design address the lack of trustworthiness of proprietary closed source TPM products, which currently dominate the whole market. lpnTPM in production mode protects software by secure boot technology, and only the lpnTPM owner will update it. TPM modules enable measured boot and support verified boot, Dynamic Root of Trust for Measurement, and other security features. Another benefit of lpnTPM would be physical design, which solves the lack of standardization around pinout and connector. The ultimate goal of lpnTPM is to provide a trustworthy platform for future open evolution of Trusted Platform Module software and its application to various computing devices, resulting in better adoption of platform security. This project was funded through the NGI Assure Fund, a fund established by NLnet with financial support from the European Commission's Next Generation Internet programme, under the aegis of DG Communications Networks, Content and Technology under grant agreement No 957073.","title":"About"},{"location":"#about","text":"lpnTPM is Open Source Software (OSS), and Open Source Hardware (OSHW) Trusted Platform Module (TPM, also known as ISO/IEC 11889) is an international standard for a secure cryptoprocessor, a dedicated microcontroller designed to secure hardware through integrated cryptographic keys. What makes lpnTPM different from generally available solutions is openness. Software and hardware of lpnTPM can, without limits, be audited, fixed, and customized by communities and businesses. Open design address the lack of trustworthiness of proprietary closed source TPM products, which currently dominate the whole market. lpnTPM in production mode protects software by secure boot technology, and only the lpnTPM owner will update it. TPM modules enable measured boot and support verified boot, Dynamic Root of Trust for Measurement, and other security features. Another benefit of lpnTPM would be physical design, which solves the lack of standardization around pinout and connector. The ultimate goal of lpnTPM is to provide a trustworthy platform for future open evolution of Trusted Platform Module software and its application to various computing devices, resulting in better adoption of platform security. This project was funded through the NGI Assure Fund, a fund established by NLnet with financial support from the European Commission's Next Generation Internet programme, under the aegis of DG Communications Networks, Content and Technology under grant agreement No 957073.","title":"About"},{"location":"building/","text":"Building, flashing, and debugging Build Here you can find our fork of Official TPM 2.0 Reference Implementation (by Microsoft) . The project is developed using STM32CubeIDE so the building process is straightforward. Just clone it with git... git clone --recurse-submodules git@github.com:lpn-plant/ms-tpm-20-ref.git cd ms-tpm-20-ref git checkout samples_stm32cubeide git submodule update ... and import it using Import -> Existing Project into Workspace in IDE Project Explorer . Select Nucleo-L476RG project from ms-tpm-20-ref/Samples/Nucleo-TPM/L476RG directory. Flash and Debug To flash/debug the application click on the green bug icon on the top toolbar and select Nucleo-L476RG Debug . If you cannot see it, select Debug Configuration... and it should be listed under STM32 Cortex-M C/C++ Application menu selection. Some extra tweaks were necessary to enable SWV ITM traces, other than that we are using the default STLink debug configuration. IDE debug configuration file is included in project root dir and should be automatically available Nucleo-L476RG Debug.launch .","title":"Building flashing and debugging"},{"location":"building/#building-flashing-and-debugging","text":"","title":"Building, flashing, and debugging"},{"location":"building/#build","text":"Here you can find our fork of Official TPM 2.0 Reference Implementation (by Microsoft) . The project is developed using STM32CubeIDE so the building process is straightforward. Just clone it with git... git clone --recurse-submodules git@github.com:lpn-plant/ms-tpm-20-ref.git cd ms-tpm-20-ref git checkout samples_stm32cubeide git submodule update ... and import it using Import -> Existing Project into Workspace in IDE Project Explorer . Select Nucleo-L476RG project from ms-tpm-20-ref/Samples/Nucleo-TPM/L476RG directory.","title":"Build"},{"location":"building/#flash-and-debug","text":"To flash/debug the application click on the green bug icon on the top toolbar and select Nucleo-L476RG Debug . If you cannot see it, select Debug Configuration... and it should be listed under STM32 Cortex-M C/C++ Application menu selection. Some extra tweaks were necessary to enable SWV ITM traces, other than that we are using the default STLink debug configuration. IDE debug configuration file is included in project root dir and should be automatically available Nucleo-L476RG Debug.launch .","title":"Flash and Debug"},{"location":"how_to/","text":"How to lpnTPM is developed around Official TPM 2.0 Reference Implementation (by Microsoft) . The project consists of a cross-platform simulator and samples both for Cortex M and Cortex A. The original port was developed on STM32L4A6RG and STM32L476RG microcontrollers using Atollic Studio. For future compatibility, we converted project files to STM32CubeIDE , which is a successor of Atollic software. The project doesn't provide any other build systems but we are definitely looking forward to use one. During the early development stage, we are using Nucleo L476RG board with USB cable connected to STM32 IO. Due to the limited amount of SRAM memory of such uC soon we will probably switch to a different one. We are currently looking at L4/F4 series in LQFP64 package. Probably for convenience, we will use some ready-made dev board as Nucleo L452RE with 160 KB of SRAM. At the current stage of development, we are using Nucleo USB CDC port to communicate to TPM core. We are targetting different interfaces - SPI, I2C, LPC is a must. STlink integrated serial port, as well as ITM traces, are used for debugging purposes.","title":"Intro"},{"location":"how_to/#how-to","text":"lpnTPM is developed around Official TPM 2.0 Reference Implementation (by Microsoft) . The project consists of a cross-platform simulator and samples both for Cortex M and Cortex A. The original port was developed on STM32L4A6RG and STM32L476RG microcontrollers using Atollic Studio. For future compatibility, we converted project files to STM32CubeIDE , which is a successor of Atollic software. The project doesn't provide any other build systems but we are definitely looking forward to use one. During the early development stage, we are using Nucleo L476RG board with USB cable connected to STM32 IO. Due to the limited amount of SRAM memory of such uC soon we will probably switch to a different one. We are currently looking at L4/F4 series in LQFP64 package. Probably for convenience, we will use some ready-made dev board as Nucleo L452RE with 160 KB of SRAM. At the current stage of development, we are using Nucleo USB CDC port to communicate to TPM core. We are targetting different interfaces - SPI, I2C, LPC is a must. STlink integrated serial port, as well as ITM traces, are used for debugging purposes.","title":"How to"},{"location":"issues/","text":"Current issues Investigate possible security issues As Jeremy Boone mention @ slack trusted-computing channel , we should investigate possible flaws in NVMem implementation. the _plat__ APIs in NVMem.c are where i\u2019ve seen the most mistakes. If you are persisting data to external flash then you need confidentiality, integrity, rollback-protection, and replay-protection. Incoming data reception and decoding Data sent from VCOM application always get received as full command located in one incoming buffer. Parsing commands make use of this feature, letting the application execute only commands, that are received at once. static int8_t CDC_Receive_FS ( uint8_t * Buf , uint32_t * Len ) { /* USER CODE BEGIN 6 */ if ( ! TpmSignalEvent ( Buf , Len )) { return ( USBD_FAIL ); } ... } Protocol analysis - early conclusions Getting STM32 to communicate with VCOM application leads us to a current yet not resolved problem. Right now we are able to execute commands on TPM, but an error occurs when the host device verifies the response data. Specifically, this line of code causes an error: * (( unsigned int * ) & response [ sizeof ( unsigned short ) + sizeof ( unsigned int )]) == 0 VCOM-TPM.cpp:198 For now, it's not clear what the response data of TPM_Startup command should look like and what each byte of command represents. Command and response data looks as follows. unsigned char CmdBuf [ 12 ] = { 0x80 , 0x01 , 0x00 , 0x00 , 0x00 , 0x0c , 0x00 , 0x00 , 0x01 , 0x44 , 0x00 , 0x00 }; unsigned char RspBuf [ 12 ] = { 0x80 , 0x01 , 0x00 , 0x00 , 0x00 , 0x0a , 0x00 , 0x00 , 0x00 , 0x00 }; This data is output via ITM trace on port 2. Correctness of data was verified on both sides of the communication. Startup command data is hardcoded in VCOM application here what makes it hard to reason about its origins. Raw data dumped from CDC_Receive_FS shows some similarities between VCOM sent command and test run of tpm2_startup -T device:/dev/ttyACM1 application. VCOM Startup command received 0x54 0x70 0x6d 0x32 0x3 0x0 0x0 0x0 0x4 0x0 0x0 0x0 0xac 0x44 0x69 0x61 0x54 0x70 0x6d 0x32 0x6 0x0 0x0 0x0 0x14 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0xc 0x0 0x0 0x0 0x80 0x1 0x0 0x0 0x0 0xc 0x0 0x0 0x1 0x44 0x0 0x0 tpm2_startup received command 0x80 0x1 0x0 0x0 0x0 0xc 0x0 0x0 0x1 0x44 0x0 0x1 As you can see VCOM sends much more bytes. Presumably two commands (?) as new the line gets appended to the log after a new pack of data gets received by CDC_Receive_FS function. static int8_t CDC_Receive_FS ( uint8_t * Buf , uint32_t * Len ) { for ( int i = 0 ; i <* Len ; i ++ ) { itmPrintAppend ( ITMSTDERR , \"0x%x \" , Buf [ i ]); } itmPrintAppend ( ITMSTDERR , \" \\n \" ); ... } What's interesting is the last 12 bytes of the received buffer, which differs only in the last byte between VCOM and tpm2_startup. Software simulator tpm-js shows exactly the same command and response data, as ITM debug output when using VCOM application. tpm-js output: PowerOn ManufactureReset Startup About to execute command TPM2_CC_Startup Command buffer (12): 0000 80 01 00 00 00 0c 00 00 01 44 00 00 .........D.. Response buffer (10): 0000 80 01 00 00 00 0a 00 00 00 00 .......... ITM port 2 output: //2021.10.14-08:52:37.000GMT unsigned char CmdBuf [ 12 ] = { 0x80 , 0x01 , 0x00 , 0x00 , 0x00 , 0x0c , 0x00 , 0x00 , 0x01 , 0x44 , 0x00 , 0x00 }; //2021.10.14-08:52:37.330GMT unsigned char RspBuf [ 12 ] = { 0x80 , 0x01 , 0x00 , 0x00 , 0x00 , 0x0a , 0x00 , 0x00 , 0x00 , 0x00 }; From what I discovered, the first 4 bytes of VCOM communication are the magic signal values from TpmDevice.h 0x54 0x70 0x6d 0x32 #define SIGNALMAGIC (0x326d7054) //Tpm2 For now, the rest of the protocol is to be discovered. Probably we should focus on getting tpm2_tools to work with STM32, as we probably don't want to port VCOM to Linux. This requires a better understanding of the communication protocol itself thus the following document will be helpful: TCG TSS 2.0 TPM Command Transmission Interface (TCTI) API Specification Section 1.3 Refedences TCG PC Client Platform TPM Profile (PTP) Specification Chapter 6 TCG TSS 2.0 TPM Command Transmission Interface (TCTI) API Specification 20.10.2021 update: The incoming data sent from VCOM application decodes as follows: 54 70 6d 32 6 0 0 0 14 0 0 0 0 0 0 0 c 0 0 0 80 1 0 0 0 c 0 0 1 44 0 0 sizeof(signalWrapper_t) { sig->s.magic '\\x54\\x70\\x6d\\x32' uint32_t hardcoded magic value sig->s.signal '\\x06\\x00\\x00\\x00' uint32_t signal enum sig->s.dataSize '\\x14\\x00\\x00\\x00' uint32_t data size } sizeof(unsigned int) * 2) { '\\x00\\x00\\x00\\x00' uint32_t locality '\\x0c\\x00\\x00\\x00' uint32_t cmdSize } actual TPM command Global.h:1098 '\\x80\\x01' TPM_ST command.tag; '\\x00\\x00'\\x00\\x0c' UINT32 commandSize; '\\x00\\x00\\x01\\x44' TPM_CC command.code '\\x00\\x00' Probably all of those header values are redundant and should be decoded using unmarshal mechanism. Memory usage Memory limitations hit us right at the beginning preventing us from building the project for STM32L476RG on both Linux STM32CubeIDE and Windows Atollic Studio. After limiting the minimal stack size in the linker script the application fits in SRAM memory, but probably the problem will hit us soon after successful execution of TPM command. At the moment of writing, we are almost out of memory. Outdated repository After struggling a lot with build errors while compiling the master branch we decided to roll back the repo. Chosen commit is the one, that adds STM32 samples. Plans involve updating the repo, eventually hitting most actual changes. Differences between STM32 and Simulator implementation of command parsing Dealing with the actual communication with TPM core we are facing some minor problems. VCOM application dedicated to TPM communication, located in ms-tpm-20-ref/Samples/Nucleo-TPM/VCOM is created using Windows, so we have to decide if we want to port it. Data packet for controlling the TPM differs between one used by tpm2_tools , Simulator, and STM32 implementation. This point needs additional investigation, but a quick glance at received data sent by using tpm2_startup -T device -d/dev/ttyACM1 --state command ensures us about it. By /dev/ACM1 port we mean STM32 USB CDC. Possible bug in build system According to the project assumptions, whole configuration is done using user_settings.h file. Previously encountered error led us to the conclusion that some parts of the aplication could be misconfigured. Some of the build switches inside TpmBuildSwitches.h could be enabled in an unwanted way. It needs to be further investigated with defines like SIMULATION and SELF_TESTS in mind. Maybe we can get some extra free RAM space this way.","title":"Current issues"},{"location":"issues/#current-issues","text":"","title":"Current issues"},{"location":"issues/#investigate-possible-security-issues","text":"As Jeremy Boone mention @ slack trusted-computing channel , we should investigate possible flaws in NVMem implementation. the _plat__ APIs in NVMem.c are where i\u2019ve seen the most mistakes. If you are persisting data to external flash then you need confidentiality, integrity, rollback-protection, and replay-protection.","title":"Investigate possible security issues"},{"location":"issues/#incoming-data-reception-and-decoding","text":"Data sent from VCOM application always get received as full command located in one incoming buffer. Parsing commands make use of this feature, letting the application execute only commands, that are received at once. static int8_t CDC_Receive_FS ( uint8_t * Buf , uint32_t * Len ) { /* USER CODE BEGIN 6 */ if ( ! TpmSignalEvent ( Buf , Len )) { return ( USBD_FAIL ); } ... }","title":"Incoming data reception and decoding"},{"location":"issues/#protocol-analysis-early-conclusions","text":"Getting STM32 to communicate with VCOM application leads us to a current yet not resolved problem. Right now we are able to execute commands on TPM, but an error occurs when the host device verifies the response data. Specifically, this line of code causes an error: * (( unsigned int * ) & response [ sizeof ( unsigned short ) + sizeof ( unsigned int )]) == 0 VCOM-TPM.cpp:198 For now, it's not clear what the response data of TPM_Startup command should look like and what each byte of command represents. Command and response data looks as follows. unsigned char CmdBuf [ 12 ] = { 0x80 , 0x01 , 0x00 , 0x00 , 0x00 , 0x0c , 0x00 , 0x00 , 0x01 , 0x44 , 0x00 , 0x00 }; unsigned char RspBuf [ 12 ] = { 0x80 , 0x01 , 0x00 , 0x00 , 0x00 , 0x0a , 0x00 , 0x00 , 0x00 , 0x00 }; This data is output via ITM trace on port 2. Correctness of data was verified on both sides of the communication. Startup command data is hardcoded in VCOM application here what makes it hard to reason about its origins. Raw data dumped from CDC_Receive_FS shows some similarities between VCOM sent command and test run of tpm2_startup -T device:/dev/ttyACM1 application. VCOM Startup command received 0x54 0x70 0x6d 0x32 0x3 0x0 0x0 0x0 0x4 0x0 0x0 0x0 0xac 0x44 0x69 0x61 0x54 0x70 0x6d 0x32 0x6 0x0 0x0 0x0 0x14 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0xc 0x0 0x0 0x0 0x80 0x1 0x0 0x0 0x0 0xc 0x0 0x0 0x1 0x44 0x0 0x0 tpm2_startup received command 0x80 0x1 0x0 0x0 0x0 0xc 0x0 0x0 0x1 0x44 0x0 0x1 As you can see VCOM sends much more bytes. Presumably two commands (?) as new the line gets appended to the log after a new pack of data gets received by CDC_Receive_FS function. static int8_t CDC_Receive_FS ( uint8_t * Buf , uint32_t * Len ) { for ( int i = 0 ; i <* Len ; i ++ ) { itmPrintAppend ( ITMSTDERR , \"0x%x \" , Buf [ i ]); } itmPrintAppend ( ITMSTDERR , \" \\n \" ); ... } What's interesting is the last 12 bytes of the received buffer, which differs only in the last byte between VCOM and tpm2_startup. Software simulator tpm-js shows exactly the same command and response data, as ITM debug output when using VCOM application. tpm-js output: PowerOn ManufactureReset Startup About to execute command TPM2_CC_Startup Command buffer (12): 0000 80 01 00 00 00 0c 00 00 01 44 00 00 .........D.. Response buffer (10): 0000 80 01 00 00 00 0a 00 00 00 00 .......... ITM port 2 output: //2021.10.14-08:52:37.000GMT unsigned char CmdBuf [ 12 ] = { 0x80 , 0x01 , 0x00 , 0x00 , 0x00 , 0x0c , 0x00 , 0x00 , 0x01 , 0x44 , 0x00 , 0x00 }; //2021.10.14-08:52:37.330GMT unsigned char RspBuf [ 12 ] = { 0x80 , 0x01 , 0x00 , 0x00 , 0x00 , 0x0a , 0x00 , 0x00 , 0x00 , 0x00 }; From what I discovered, the first 4 bytes of VCOM communication are the magic signal values from TpmDevice.h 0x54 0x70 0x6d 0x32 #define SIGNALMAGIC (0x326d7054) //Tpm2 For now, the rest of the protocol is to be discovered. Probably we should focus on getting tpm2_tools to work with STM32, as we probably don't want to port VCOM to Linux. This requires a better understanding of the communication protocol itself thus the following document will be helpful: TCG TSS 2.0 TPM Command Transmission Interface (TCTI) API Specification Section 1.3 Refedences TCG PC Client Platform TPM Profile (PTP) Specification Chapter 6 TCG TSS 2.0 TPM Command Transmission Interface (TCTI) API Specification 20.10.2021 update: The incoming data sent from VCOM application decodes as follows: 54 70 6d 32 6 0 0 0 14 0 0 0 0 0 0 0 c 0 0 0 80 1 0 0 0 c 0 0 1 44 0 0 sizeof(signalWrapper_t) { sig->s.magic '\\x54\\x70\\x6d\\x32' uint32_t hardcoded magic value sig->s.signal '\\x06\\x00\\x00\\x00' uint32_t signal enum sig->s.dataSize '\\x14\\x00\\x00\\x00' uint32_t data size } sizeof(unsigned int) * 2) { '\\x00\\x00\\x00\\x00' uint32_t locality '\\x0c\\x00\\x00\\x00' uint32_t cmdSize } actual TPM command Global.h:1098 '\\x80\\x01' TPM_ST command.tag; '\\x00\\x00'\\x00\\x0c' UINT32 commandSize; '\\x00\\x00\\x01\\x44' TPM_CC command.code '\\x00\\x00' Probably all of those header values are redundant and should be decoded using unmarshal mechanism.","title":"Protocol analysis - early conclusions"},{"location":"issues/#memory-usage","text":"Memory limitations hit us right at the beginning preventing us from building the project for STM32L476RG on both Linux STM32CubeIDE and Windows Atollic Studio. After limiting the minimal stack size in the linker script the application fits in SRAM memory, but probably the problem will hit us soon after successful execution of TPM command. At the moment of writing, we are almost out of memory.","title":"Memory usage"},{"location":"issues/#outdated-repository","text":"After struggling a lot with build errors while compiling the master branch we decided to roll back the repo. Chosen commit is the one, that adds STM32 samples. Plans involve updating the repo, eventually hitting most actual changes.","title":"Outdated repository"},{"location":"issues/#differences-between-stm32-and-simulator-implementation-of-command-parsing","text":"Dealing with the actual communication with TPM core we are facing some minor problems. VCOM application dedicated to TPM communication, located in ms-tpm-20-ref/Samples/Nucleo-TPM/VCOM is created using Windows, so we have to decide if we want to port it. Data packet for controlling the TPM differs between one used by tpm2_tools , Simulator, and STM32 implementation. This point needs additional investigation, but a quick glance at received data sent by using tpm2_startup -T device -d/dev/ttyACM1 --state command ensures us about it. By /dev/ACM1 port we mean STM32 USB CDC.","title":"Differences between STM32 and Simulator implementation of command parsing"},{"location":"issues/#possible-bug-in-build-system","text":"According to the project assumptions, whole configuration is done using user_settings.h file. Previously encountered error led us to the conclusion that some parts of the aplication could be misconfigured. Some of the build switches inside TpmBuildSwitches.h could be enabled in an unwanted way. It needs to be further investigated with defines like SIMULATION and SELF_TESTS in mind. Maybe we can get some extra free RAM space this way.","title":"Possible bug in build system"},{"location":"journal/","text":"Journal 04-08.10.2021 Fixing compilation problems. Converting project to STM32CubeIDE. Setup ITM trace logging. 11-15.10.2021 Getting USB CDC work. Experiments with tpm2-tools. Writing documentation. Investigation of memory usage and choosing best suited hw platform. 14.10.2021 building and running VCOM project Samples/Nucleo-TPM/VCOM (Visual Studio 2017). first successful communication with TPM core investigation the root cause of response check failing link 15.10.2021 small fix for NDEBUG enabled compilation protocol analysis 18.10.2021 protocol analysis 19.10.2021 protocol analysis decoding command and response data frames setting up lib tpm2-tss and tpm2-pytss for future communication 20.10.2021 protocol analysis investigation of lib tpm2-tss and tpm2-pytss behaviour and wrong packet reception","title":"Journal"},{"location":"journal/#journal","text":"04-08.10.2021 Fixing compilation problems. Converting project to STM32CubeIDE. Setup ITM trace logging. 11-15.10.2021 Getting USB CDC work. Experiments with tpm2-tools. Writing documentation. Investigation of memory usage and choosing best suited hw platform. 14.10.2021 building and running VCOM project Samples/Nucleo-TPM/VCOM (Visual Studio 2017). first successful communication with TPM core investigation the root cause of response check failing link 15.10.2021 small fix for NDEBUG enabled compilation protocol analysis 18.10.2021 protocol analysis 19.10.2021 protocol analysis decoding command and response data frames setting up lib tpm2-tss and tpm2-pytss for future communication 20.10.2021 protocol analysis investigation of lib tpm2-tss and tpm2-pytss behaviour and wrong packet reception","title":"Journal"},{"location":"running/","text":"Running The project is using three communication interfaces to debug and talk to TPM core. TPM core communication is handled by STM32 USB CDC interface. See https://github.com/microsoft/ms-tpm-20-ref/blob/master/Samples/Nucleo-TPM/USB_Hookup.jpg printf is forwarded to the integrated STLink VCOM. fprintf(stderr, *) could be received on port 0 of ITM SWV. dbgPrint uses port 1 of ITM SWV. ITM trace configuration For now, ITM trace output is available only through STM32CubeIDE. We are planning to add this feature using command-line tools like openocd or STM32_Programmer_CLI . To view ITM output first you should enable SWV ITM console, by selecting it in Window -> Show View -> Other . Next thing is to start to debug the application and when it hits the first breakpoint select Configure trace under SWV ITM console. Select the first three channels and accept. After that you should be ready to go, so just click Start Trace - red dot icon and hit F8 to continue program execution. Now you should see trace debug output like in the picture below. USB CDC configuration On some platforms (Ubuntu in my case) '/dev/ttyACM*' ports automatically receive AT commands just after plugging USB cable. As we are using raw data format to communicate with TPM device and STM32 CDC port mount as /dev/ACM* device this could be problematic. To stop receiving AT commands just disable ModemManager service with the following command: systemctl stop ModemManager sudo systemctl disable ModemManager","title":"Running"},{"location":"running/#running","text":"The project is using three communication interfaces to debug and talk to TPM core. TPM core communication is handled by STM32 USB CDC interface. See https://github.com/microsoft/ms-tpm-20-ref/blob/master/Samples/Nucleo-TPM/USB_Hookup.jpg printf is forwarded to the integrated STLink VCOM. fprintf(stderr, *) could be received on port 0 of ITM SWV. dbgPrint uses port 1 of ITM SWV.","title":"Running"},{"location":"running/#itm-trace-configuration","text":"For now, ITM trace output is available only through STM32CubeIDE. We are planning to add this feature using command-line tools like openocd or STM32_Programmer_CLI . To view ITM output first you should enable SWV ITM console, by selecting it in Window -> Show View -> Other . Next thing is to start to debug the application and when it hits the first breakpoint select Configure trace under SWV ITM console. Select the first three channels and accept. After that you should be ready to go, so just click Start Trace - red dot icon and hit F8 to continue program execution. Now you should see trace debug output like in the picture below.","title":"ITM trace configuration"},{"location":"running/#usb-cdc-configuration","text":"On some platforms (Ubuntu in my case) '/dev/ttyACM*' ports automatically receive AT commands just after plugging USB cable. As we are using raw data format to communicate with TPM device and STM32 CDC port mount as /dev/ACM* device this could be problematic. To stop receiving AT commands just disable ModemManager service with the following command: systemctl stop ModemManager sudo systemctl disable ModemManager","title":"USB CDC configuration"}]}